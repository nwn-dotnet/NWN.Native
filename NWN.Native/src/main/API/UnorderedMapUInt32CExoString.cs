//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 4.0.2
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace NWN.Native.API {

public unsafe class UnorderedMapUInt32CExoString : global::System.IDisposable, global::System.Collections.Generic.IDictionary<uint, CExoString> {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal UnorderedMapUInt32CExoString(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(UnorderedMapUInt32CExoString obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~UnorderedMapUInt32CExoString() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          NWNXLibPINVOKE.delete_UnorderedMapUInt32CExoString(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public global::System.IntPtr Pointer {
    get {
      return swigCPtr.Handle;
    }
  }

  public static unsafe implicit operator void*(UnorderedMapUInt32CExoString self) {
    return (void*)self.swigCPtr.Handle;
  }

  public static unsafe UnorderedMapUInt32CExoString FromPointer(void* pointer, bool memoryOwn = false) {
    return pointer != null ? new UnorderedMapUInt32CExoString((global::System.IntPtr)pointer, memoryOwn) : null;
  }

  public static UnorderedMapUInt32CExoString FromPointer(global::System.IntPtr pointer, bool memoryOwn = false) {
    return pointer != global::System.IntPtr.Zero ? new UnorderedMapUInt32CExoString(pointer, memoryOwn) : null;
  }

  public bool Equals(UnorderedMapUInt32CExoString other) {
    if (ReferenceEquals(null, other)) {
      return false;
    }

    if (ReferenceEquals(this, other)) {
      return true;
    }

    return Pointer.Equals(other.Pointer);
  }

  public override bool Equals(object obj) {
    return ReferenceEquals(this, obj) || obj is UnorderedMapUInt32CExoString other && Equals(other);
  }

  public override int GetHashCode() {
    return swigCPtr.Handle.GetHashCode();
  }

  public static bool operator ==(UnorderedMapUInt32CExoString left, UnorderedMapUInt32CExoString right) {
    return Equals(left, right);
  }

  public static bool operator !=(UnorderedMapUInt32CExoString left, UnorderedMapUInt32CExoString right) {
    return !Equals(left, right);
  }

  public bool IsReadOnly
  {
    get => false;
  }

  public int Count
  {
    get => (int)size();
  }

  public CExoString this[uint key]
  {
    get
    {
      Iterator iterator = find(key);
      if (iterator.IsEqual(end()))
      {
         throw new global::System.Collections.Generic.KeyNotFoundException("The given key was not present in the UnorderedMap.");
      }

      return iterator.GetValue();
    }

    set => InternalSetValue(key, value);
  }

  public bool Remove(uint key)
  {
    Iterator iterator = find(key);
    if (!iterator.IsEqual(end()))
    {
      InternalRemove(iterator);
      return true;
    }

    return false;
  }

  public bool TryGetValue(uint key, out CExoString value)
  {
      Iterator iterator = find(key);
      if (iterator.IsEqual(end()))
      {
         value = default;
         return false;
      }

      value = iterator.GetValue();
      return true;
  }

  public global::System.Collections.Generic.ICollection<uint> Keys
  {
    get
    {
      int startCount = Count;
      Iterator iterator = begin();
      Iterator endIterator = end();

      global::System.Collections.Generic.ICollection<uint> keys = new global::System.Collections.Generic.List<uint>();

      while (!iterator.IsEqual(endIterator))
      {
        if (Count != startCount)
        {
          throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
        }

        keys.Add(iterator.GetKey());
        iterator = iterator.MoveNext();
      }

      return keys;
    }
  }

  public global::System.Collections.Generic.ICollection<CExoString> Values
  {
    get
    {
      int startCount = Count;
      Iterator iterator = begin();
      Iterator endIterator = end();

      global::System.Collections.Generic.ICollection<CExoString> values = new global::System.Collections.Generic.List<CExoString>();

      while (!iterator.IsEqual(endIterator))
      {
        if (Count != startCount)
        {
          throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
        }

        values.Add(iterator.GetValue());
        iterator = iterator.MoveNext();
      }

      return values;
    }
  }

  public void Add(uint key, CExoString value)
  {
    if (ContainsKey(key))
    {
      throw new global::System.ArgumentException(nameof(key), "An item with the same key has already been added.");
    }

    InternalSetValue(key, value);
  }

  public void Add(global::System.Collections.Generic.KeyValuePair<uint, CExoString> item)
  {
    Add(item.Key, item.Value);
  }

  bool global::System.Collections.Generic.ICollection<global::System.Collections.Generic.KeyValuePair<uint, CExoString>>.Contains(global::System.Collections.Generic.KeyValuePair<uint, CExoString> keyValuePair)
  {
    return TryGetValue(keyValuePair.Key, out CExoString value) && value == keyValuePair.Value;
  }

  bool global::System.Collections.Generic.ICollection<global::System.Collections.Generic.KeyValuePair<uint, CExoString>>.Remove(global::System.Collections.Generic.KeyValuePair<uint, CExoString> keyValuePair)
  {
    Iterator iterator = find(keyValuePair.Key);
    if (!iterator.IsEqual(end()) && iterator.GetValue() == keyValuePair.Value)
    {
      InternalRemove(iterator);
      return true;
    }

    return false;
  }

  public void CopyTo(global::System.Collections.Generic.KeyValuePair<uint, CExoString>[] array)
  {
    CopyTo(array, 0);
  }

  public void CopyTo(global::System.Collections.Generic.KeyValuePair<uint, CExoString>[] array, int arrayIndex)
  {
    if (array == null)
      throw new global::System.ArgumentNullException("array");
    if (arrayIndex < 0)
      throw new global::System.ArgumentOutOfRangeException("arrayIndex", "Value is less than zero");
    if (array.Rank > 1)
      throw new global::System.ArgumentException("Multi dimensional array.", "array");
    if (arrayIndex+this.Count > array.Length)
      throw new global::System.ArgumentException("Number of elements to copy is too large.");

    int startCount = Count;
    Iterator iterator = begin();
    Iterator endIterator = end();

    for (int i = 0; i < Count && !iterator.IsEqual(endIterator); i++, iterator = iterator.MoveNext())
    {
      if (Count != startCount)
      {
        throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
      }

      array.SetValue(new global::System.Collections.Generic.KeyValuePair<uint, CExoString>(iterator.GetKey(), iterator.GetValue()), arrayIndex+i);
    }
  }

  public global::System.Collections.Generic.IEnumerator<global::System.Collections.Generic.KeyValuePair<uint, CExoString>> GetEnumerator()
  {
    int startCount = Count;
    Iterator iterator = begin();
    Iterator endIterator = end();

    while (!iterator.IsEqual(endIterator))
    {
      if (Count != startCount)
      {
        throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
      }

      yield return new global::System.Collections.Generic.KeyValuePair<uint, CExoString>(iterator.GetKey(), iterator.GetValue());
      iterator = iterator.MoveNext();
    }
  }

  global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
  {
    return GetEnumerator();
  }

  public UnorderedMapUInt32CExoString() : this(NWNXLibPINVOKE.new_UnorderedMapUInt32CExoString__SWIG_0(), true) {
  }

  public UnorderedMapUInt32CExoString(UnorderedMapUInt32CExoString other) : this(NWNXLibPINVOKE.new_UnorderedMapUInt32CExoString__SWIG_1(UnorderedMapUInt32CExoString.getCPtr(other)), true) {
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
  }

  private class Iterator : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal Iterator(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Iterator obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    ~Iterator() {
      Dispose(false);
    }
  
    public void Dispose() {
      Dispose(true);
      global::System.GC.SuppressFinalize(this);
    }
  
    protected virtual void Dispose(bool disposing) {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            NWNXLibPINVOKE.delete_UnorderedMapUInt32CExoString_Iterator(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
      }
    }
  
    public global::System.IntPtr Pointer {
      get {
        return swigCPtr.Handle;
      }
    }
  
    public static unsafe implicit operator void*(Iterator self) {
      return (void*)self.swigCPtr.Handle;
    }
  
    public static unsafe Iterator FromPointer(void* pointer, bool memoryOwn = false) {
      return pointer != null ? new Iterator((global::System.IntPtr)pointer, memoryOwn) : null;
    }
  
    public static Iterator FromPointer(global::System.IntPtr pointer, bool memoryOwn = false) {
      return pointer != global::System.IntPtr.Zero ? new Iterator(pointer, memoryOwn) : null;
    }
  
    public bool Equals(Iterator other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
  
      if (ReferenceEquals(this, other)) {
        return true;
      }
  
      return Pointer.Equals(other.Pointer);
    }
  
    public override bool Equals(object obj) {
      return ReferenceEquals(this, obj) || obj is Iterator other && Equals(other);
    }
  
    public override int GetHashCode() {
      return swigCPtr.Handle.GetHashCode();
    }
  
    public static bool operator ==(Iterator left, Iterator right) {
      return Equals(left, right);
    }
  
    public static bool operator !=(Iterator left, Iterator right) {
      return !Equals(left, right);
    }
  
    public UnorderedMapUInt32CExoString.Iterator MoveNext() {
      UnorderedMapUInt32CExoString.Iterator ret = new UnorderedMapUInt32CExoString.Iterator(NWNXLibPINVOKE.UnorderedMapUInt32CExoString_Iterator_MoveNext(swigCPtr), true);
      return ret;
    }
  
    internal bool IsEqual(UnorderedMapUInt32CExoString.Iterator other) {
      bool ret = NWNXLibPINVOKE.UnorderedMapUInt32CExoString_Iterator_IsEqual(swigCPtr, UnorderedMapUInt32CExoString.Iterator.getCPtr(other));
      if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  
    internal uint GetKey() {
      uint retVal = NWNXLibPINVOKE.UnorderedMapUInt32CExoString_Iterator_GetKey(swigCPtr);
      return retVal;
    }
  
    internal CExoString GetValue() {
      CExoString ret = new CExoString(NWNXLibPINVOKE.UnorderedMapUInt32CExoString_Iterator_GetValue(swigCPtr), true);
      return ret;
    }
  
    internal void SetValue(CExoString newValue) {
      NWNXLibPINVOKE.UnorderedMapUInt32CExoString_Iterator_SetValue(swigCPtr, CExoString.getCPtr(newValue));
      if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
    }
  
  }

  private uint size() {
    uint ret = NWNXLibPINVOKE.UnorderedMapUInt32CExoString_size(swigCPtr);
    return ret;
  }

  public void Clear() {
    NWNXLibPINVOKE.UnorderedMapUInt32CExoString_Clear(swigCPtr);
  }

  private UnorderedMapUInt32CExoString.Iterator find(uint key) {
    UnorderedMapUInt32CExoString.Iterator ret = new UnorderedMapUInt32CExoString.Iterator(NWNXLibPINVOKE.UnorderedMapUInt32CExoString_find(swigCPtr, key), true);
    return ret;
  }

  private UnorderedMapUInt32CExoString.Iterator begin() {
    UnorderedMapUInt32CExoString.Iterator ret = new UnorderedMapUInt32CExoString.Iterator(NWNXLibPINVOKE.UnorderedMapUInt32CExoString_begin(swigCPtr), true);
    return ret;
  }

  private UnorderedMapUInt32CExoString.Iterator end() {
    UnorderedMapUInt32CExoString.Iterator ret = new UnorderedMapUInt32CExoString.Iterator(NWNXLibPINVOKE.UnorderedMapUInt32CExoString_end(swigCPtr), true);
    return ret;
  }

  public bool ContainsKey(uint key) {
    bool ret = NWNXLibPINVOKE.UnorderedMapUInt32CExoString_ContainsKey(swigCPtr, key);
    return ret;
  }

  private void InternalSetValue(uint key, CExoString value) {
    NWNXLibPINVOKE.UnorderedMapUInt32CExoString_InternalSetValue(swigCPtr, key, CExoString.getCPtr(value));
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
  }

  private void InternalRemove(UnorderedMapUInt32CExoString.Iterator itr) {
    NWNXLibPINVOKE.UnorderedMapUInt32CExoString_InternalRemove(swigCPtr, UnorderedMapUInt32CExoString.Iterator.getCPtr(itr));
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
  }

}

}
