//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 4.0.2
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace NWN.Native.API {

public unsafe class UnorderedMapStringCachedRulesetEntry : global::System.IDisposable, global::System.Collections.Generic.IDictionary<string, CachedRulesetEntry> {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal UnorderedMapStringCachedRulesetEntry(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(UnorderedMapStringCachedRulesetEntry obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~UnorderedMapStringCachedRulesetEntry() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          NWNXLibPINVOKE.delete_UnorderedMapStringCachedRulesetEntry(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public global::System.IntPtr Pointer {
    get {
      return swigCPtr.Handle;
    }
  }

  public static unsafe implicit operator void*(UnorderedMapStringCachedRulesetEntry self) {
    return (void*)self.swigCPtr.Handle;
  }

  public static unsafe UnorderedMapStringCachedRulesetEntry FromPointer(void* pointer, bool memoryOwn = false) {
    return pointer != null ? new UnorderedMapStringCachedRulesetEntry((global::System.IntPtr)pointer, memoryOwn) : null;
  }

  public static UnorderedMapStringCachedRulesetEntry FromPointer(global::System.IntPtr pointer, bool memoryOwn = false) {
    return pointer != global::System.IntPtr.Zero ? new UnorderedMapStringCachedRulesetEntry(pointer, memoryOwn) : null;
  }

  public bool Equals(UnorderedMapStringCachedRulesetEntry other) {
    if (ReferenceEquals(null, other)) {
      return false;
    }

    if (ReferenceEquals(this, other)) {
      return true;
    }

    return Pointer.Equals(other.Pointer);
  }

  public override bool Equals(object obj) {
    return ReferenceEquals(this, obj) || obj is UnorderedMapStringCachedRulesetEntry other && Equals(other);
  }

  public override int GetHashCode() {
    return swigCPtr.Handle.GetHashCode();
  }

  public static bool operator ==(UnorderedMapStringCachedRulesetEntry left, UnorderedMapStringCachedRulesetEntry right) {
    return Equals(left, right);
  }

  public static bool operator !=(UnorderedMapStringCachedRulesetEntry left, UnorderedMapStringCachedRulesetEntry right) {
    return !Equals(left, right);
  }

  public bool IsReadOnly
  {
    get => false;
  }

  public int Count
  {
    get => (int)size();
  }

  public CachedRulesetEntry this[string key]
  {
    get
    {
      Iterator iterator = find(key);
      if (iterator.IsEqual(end()))
      {
         throw new global::System.Collections.Generic.KeyNotFoundException("The given key was not present in the UnorderedMap.");
      }

      return iterator.GetValue();
    }

    set => InternalSetValue(key, value);
  }

  public bool Remove(string key)
  {
    Iterator iterator = find(key);
    if (!iterator.IsEqual(end()))
    {
      InternalRemove(iterator);
      return true;
    }

    return false;
  }

  public bool TryGetValue(string key, out CachedRulesetEntry value)
  {
      Iterator iterator = find(key);
      if (iterator.IsEqual(end()))
      {
         value = default;
         return false;
      }

      value = iterator.GetValue();
      return true;
  }

  public global::System.Collections.Generic.ICollection<string> Keys
  {
    get
    {
      int startCount = Count;
      Iterator iterator = begin();
      Iterator endIterator = end();

      global::System.Collections.Generic.ICollection<string> keys = new global::System.Collections.Generic.List<string>();

      while (!iterator.IsEqual(endIterator))
      {
        if (Count != startCount)
        {
          throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
        }

        keys.Add(iterator.GetKey());
        iterator = iterator.MoveNext();
      }

      return keys;
    }
  }

  public global::System.Collections.Generic.ICollection<CachedRulesetEntry> Values
  {
    get
    {
      int startCount = Count;
      Iterator iterator = begin();
      Iterator endIterator = end();

      global::System.Collections.Generic.ICollection<CachedRulesetEntry> values = new global::System.Collections.Generic.List<CachedRulesetEntry>();

      while (!iterator.IsEqual(endIterator))
      {
        if (Count != startCount)
        {
          throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
        }

        values.Add(iterator.GetValue());
        iterator = iterator.MoveNext();
      }

      return values;
    }
  }

  public void Add(string key, CachedRulesetEntry value)
  {
    if (ContainsKey(key))
    {
      throw new global::System.ArgumentException(nameof(key), "An item with the same key has already been added.");
    }

    InternalSetValue(key, value);
  }

  public void Add(global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry> item)
  {
    Add(item.Key, item.Value);
  }

  bool global::System.Collections.Generic.ICollection<global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry>>.Contains(global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry> keyValuePair)
  {
    return TryGetValue(keyValuePair.Key, out CachedRulesetEntry value) && value == keyValuePair.Value;
  }

  bool global::System.Collections.Generic.ICollection<global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry>>.Remove(global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry> keyValuePair)
  {
    Iterator iterator = find(keyValuePair.Key);
    if (!iterator.IsEqual(end()) && iterator.GetValue() == keyValuePair.Value)
    {
      InternalRemove(iterator);
      return true;
    }

    return false;
  }

  public void CopyTo(global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry>[] array)
  {
    CopyTo(array, 0);
  }

  public void CopyTo(global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry>[] array, int arrayIndex)
  {
    if (array == null)
      throw new global::System.ArgumentNullException("array");
    if (arrayIndex < 0)
      throw new global::System.ArgumentOutOfRangeException("arrayIndex", "Value is less than zero");
    if (array.Rank > 1)
      throw new global::System.ArgumentException("Multi dimensional array.", "array");
    if (arrayIndex+this.Count > array.Length)
      throw new global::System.ArgumentException("Number of elements to copy is too large.");

    int startCount = Count;
    Iterator iterator = begin();
    Iterator endIterator = end();

    for (int i = 0; i < Count && !iterator.IsEqual(endIterator); i++, iterator = iterator.MoveNext())
    {
      if (Count != startCount)
      {
        throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
      }

      array.SetValue(new global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry>(iterator.GetKey(), iterator.GetValue()), arrayIndex+i);
    }
  }

  public global::System.Collections.Generic.IEnumerator<global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry>> GetEnumerator()
  {
    int startCount = Count;
    Iterator iterator = begin();
    Iterator endIterator = end();

    while (!iterator.IsEqual(endIterator))
    {
      if (Count != startCount)
      {
        throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");
      }

      yield return new global::System.Collections.Generic.KeyValuePair<string, CachedRulesetEntry>(iterator.GetKey(), iterator.GetValue());
      iterator = iterator.MoveNext();
    }
  }

  global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator()
  {
    return GetEnumerator();
  }

  public UnorderedMapStringCachedRulesetEntry() : this(NWNXLibPINVOKE.new_UnorderedMapStringCachedRulesetEntry__SWIG_0(), true) {
  }

  public UnorderedMapStringCachedRulesetEntry(UnorderedMapStringCachedRulesetEntry other) : this(NWNXLibPINVOKE.new_UnorderedMapStringCachedRulesetEntry__SWIG_1(UnorderedMapStringCachedRulesetEntry.getCPtr(other)), true) {
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
  }

  private class Iterator : global::System.IDisposable {
    private global::System.Runtime.InteropServices.HandleRef swigCPtr;
    protected bool swigCMemOwn;
  
    internal Iterator(global::System.IntPtr cPtr, bool cMemoryOwn) {
      swigCMemOwn = cMemoryOwn;
      swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
    }
  
    internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Iterator obj) {
      return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
    }
  
    ~Iterator() {
      Dispose(false);
    }
  
    public void Dispose() {
      Dispose(true);
      global::System.GC.SuppressFinalize(this);
    }
  
    protected virtual void Dispose(bool disposing) {
      lock(this) {
        if (swigCPtr.Handle != global::System.IntPtr.Zero) {
          if (swigCMemOwn) {
            swigCMemOwn = false;
            NWNXLibPINVOKE.delete_UnorderedMapStringCachedRulesetEntry_Iterator(swigCPtr);
          }
          swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
        }
      }
    }
  
    public global::System.IntPtr Pointer {
      get {
        return swigCPtr.Handle;
      }
    }
  
    public static unsafe implicit operator void*(Iterator self) {
      return (void*)self.swigCPtr.Handle;
    }
  
    public static unsafe Iterator FromPointer(void* pointer, bool memoryOwn = false) {
      return pointer != null ? new Iterator((global::System.IntPtr)pointer, memoryOwn) : null;
    }
  
    public static Iterator FromPointer(global::System.IntPtr pointer, bool memoryOwn = false) {
      return pointer != global::System.IntPtr.Zero ? new Iterator(pointer, memoryOwn) : null;
    }
  
    public bool Equals(Iterator other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
  
      if (ReferenceEquals(this, other)) {
        return true;
      }
  
      return Pointer.Equals(other.Pointer);
    }
  
    public override bool Equals(object obj) {
      return ReferenceEquals(this, obj) || obj is Iterator other && Equals(other);
    }
  
    public override int GetHashCode() {
      return swigCPtr.Handle.GetHashCode();
    }
  
    public static bool operator ==(Iterator left, Iterator right) {
      return Equals(left, right);
    }
  
    public static bool operator !=(Iterator left, Iterator right) {
      return !Equals(left, right);
    }
  
    public UnorderedMapStringCachedRulesetEntry.Iterator MoveNext() {
      UnorderedMapStringCachedRulesetEntry.Iterator ret = new UnorderedMapStringCachedRulesetEntry.Iterator(NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_Iterator_MoveNext(swigCPtr), true);
      return ret;
    }
  
    internal bool IsEqual(UnorderedMapStringCachedRulesetEntry.Iterator other) {
      bool ret = NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_Iterator_IsEqual(swigCPtr, UnorderedMapStringCachedRulesetEntry.Iterator.getCPtr(other));
      if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  
    internal string GetKey() {
      string ret = NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_Iterator_GetKey(swigCPtr);
      return ret;
    }
  
    internal CachedRulesetEntry GetValue() {
      CachedRulesetEntry ret = new CachedRulesetEntry(NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_Iterator_GetValue(swigCPtr), true);
      return ret;
    }
  
    internal void SetValue(CachedRulesetEntry newValue) {
      NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_Iterator_SetValue(swigCPtr, CachedRulesetEntry.getCPtr(newValue));
      if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
    }
  
  }

  private uint size() {
    uint ret = NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_size(swigCPtr);
    return ret;
  }

  public void Clear() {
    NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_Clear(swigCPtr);
  }

  private UnorderedMapStringCachedRulesetEntry.Iterator find(string key) {
    UnorderedMapStringCachedRulesetEntry.Iterator ret = new UnorderedMapStringCachedRulesetEntry.Iterator(NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_find(swigCPtr, key), true);
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private UnorderedMapStringCachedRulesetEntry.Iterator begin() {
    UnorderedMapStringCachedRulesetEntry.Iterator ret = new UnorderedMapStringCachedRulesetEntry.Iterator(NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_begin(swigCPtr), true);
    return ret;
  }

  private UnorderedMapStringCachedRulesetEntry.Iterator end() {
    UnorderedMapStringCachedRulesetEntry.Iterator ret = new UnorderedMapStringCachedRulesetEntry.Iterator(NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_end(swigCPtr), true);
    return ret;
  }

  public bool ContainsKey(string key) {
    bool ret = NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_ContainsKey(swigCPtr, key);
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private void InternalSetValue(string key, CachedRulesetEntry value) {
    NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_InternalSetValue(swigCPtr, key, CachedRulesetEntry.getCPtr(value));
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
  }

  private void InternalRemove(UnorderedMapStringCachedRulesetEntry.Iterator itr) {
    NWNXLibPINVOKE.UnorderedMapStringCachedRulesetEntry_InternalRemove(swigCPtr, UnorderedMapStringCachedRulesetEntry.Iterator.getCPtr(itr));
    if (NWNXLibPINVOKE.SWIGPendingException.Pending) throw NWNXLibPINVOKE.SWIGPendingException.Retrieve();
  }

}

}
